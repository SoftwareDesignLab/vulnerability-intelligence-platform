package edu.rit.se.nvip.patchfinder;

import edu.rit.se.nvip.db.DatabaseHelper;
import edu.rit.se.nvip.utils.email.EmailDailyCveList;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.diff.DiffEntry;
import org.eclipse.jgit.diff.DiffFormatter;
import org.eclipse.jgit.errors.MissingObjectException;
import org.eclipse.jgit.lib.*;
import org.eclipse.jgit.revwalk.RevCommit;
import org.eclipse.jgit.revwalk.RevTree;
import org.eclipse.jgit.revwalk.RevWalk;
import org.eclipse.jgit.treewalk.AbstractTreeIterator;
import org.eclipse.jgit.treewalk.CanonicalTreeParser;
import org.eclipse.jgit.treewalk.TreeWalk;
import org.eclipse.jgit.treewalk.filter.PathFilter;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.parser.Parser;
import org.jsoup.select.Elements;

import java.io.*;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;

/**
 * Extract Class for writing patch contents to an extract CSV file that is stored locally,
 * Will also call to the Database for exploit info
 */
public class CSVWriter {

    private static final Logger logger = LogManager.getLogger(CSVWriter.class.getSimpleName());
    private static final DatabaseHelper db = DatabaseHelper.getInstance();
    private Repository localRepo;
    private String projectName;
    private String localOutput;
    private String cveId;
    private String description;
    private Git git;

    public static void main(String[] args) {
        logger.info("Starting CSVWriter");
        CSVWriter main = new CSVWriter("CVE-2017-5831");

        try {
            main.getCWEId(new StringBuilder());
        } catch (Exception e) {
            logger.error(e);
        }
    }

    public CSVWriter(String cveId) {
        this.cveId = cveId;
    }

    public CSVWriter(Repository localRepo, String localOutput, String projectName, Git git, String cveId, String description) {
        this.localRepo = localRepo;
        this.localOutput = localOutput;
        this.projectName = projectName;
        this.git = git;
        this.cveId = cveId;
        this.description = description;
    }


    /**
     * Creates Commit files for every CVE including a patch within the output
     * directory
     *
     * @param cveTag
     * @param commit
     * @throws MissingObjectException
     * @throws IOException
     * @throws GitAPIException
     */
    public ArrayList<String> saveCommitFiles(String cveTag, String commitState, RevCommit commit, List<String> filePathsByCommit) {

        logger.info("Saving commit files for: " + cveTag);
        ArrayList<String> commitFilePaths = new ArrayList<>();
        RevTree tree = commit.getTree();
        TreeWalk extractObjectTree;
        // now try to find a specific file
        try (TreeWalk treeWalk = new TreeWalk(localRepo)) {

            treeWalk.addTree(tree);
            treeWalk.setRecursive(true);

            // Loop through all commit files and re-write them in CVE_Patches directory
            // Within the selected output dir
            for (String path : filePathsByCommit) {

                treeWalk.setFilter(PathFilter.create(path));
                Path p = Paths.get(path);
                String fileName = p.getFileName().toString();

                if (!treeWalk.next()) {
                    System.out.println("Did not find expected file");
                    break;
                }

                extractObjectTree = treeWalk;
                ObjectId objectId = extractObjectTree.getObjectId(0);
                ObjectLoader loader = localRepo.open(objectId);

                ByteArrayOutputStream os = new ByteArrayOutputStream();
                loader.copyTo(os);

                // Folder in which the Patch commit and diff is stored
                File cveFolder = new File(localOutput + File.separator + projectName);
                cveFolder.mkdir();

                // CVE_Patches folder for all commit files
                File cvePatches = new File(cveFolder.getAbsolutePath() + File.separator + "CVE_Patches");
                cvePatches.mkdir();

                // Folder for specific CVE
                File dir = new File(cvePatches.getAbsolutePath() + File.separator + cveTag);
                dir.mkdir();

                // Folder for specific CVE
                File loc = new File(dir.getAbsolutePath() + File.separator + commitState);
                loc.mkdir();

                File commitFile = new File(loc.getAbsolutePath() + File.separator + fileName);

                // Write commit contents
                try (OutputStream outputStream = new FileOutputStream(
                        commitFile.getAbsolutePath())) {
                    os.writeTo(outputStream);
                }

                Path commitFilePath = Paths.get(commitFile.getAbsolutePath());
                Charset charset = StandardCharsets.UTF_8;

                String commitContent = Files.readString(commitFilePath, charset);
                commitContent = commitContent.replaceAll(",", "COMMA");
                commitContent = commitContent.replaceAll("\n", "\\N");

                Files.write(commitFilePath, commitContent.getBytes(charset));

                commitFilePaths.add(commitFile.getAbsolutePath());
            }

        } catch (Exception e) {
            logger.error(e.toString());
        }

        logger.info("Commit files saved");
        return commitFilePaths;

    }

    /**
     * Creates Diff file for every CVE including a patch within the output directory
     *
     * @param cveTag
     * @param commit
     * @throws GitAPIException
     * @throws IOException
     */

    public ArrayList<String> saveDiffFiles(String cveTag, RevCommit commit) throws GitAPIException, IOException {

        logger.info("Saving diff files for: " + cveTag);
        ArrayList<String> diffFilePaths = new ArrayList<>();
        List<DiffEntry> diff = getDiff(commit);

        String commitName = commit.getName();

        // Folder in which the Patch commit and diff is stored
        File cveFolder = new File(localOutput + File.separator + projectName);
        cveFolder.mkdir();

        // CVE_Patches folder for all diff files
        File cvePatches = new File(cveFolder.getAbsolutePath() + File.separator + "CVE_Diffs");
        cvePatches.mkdir();

        // Folder for specific CVE
        File dir = new File(cvePatches.getAbsolutePath() + File.separator + cveTag);
        dir.mkdir();
        // Folder for specific commit containing the hash (named after commit hash)
        File commHash = new File(dir.getAbsolutePath() + File.separator + commitName);
        commHash.mkdir();

        // OutputStream outputStream = new FileOutputStream(commHash.getAbsolutePath() +
        // File.separator + "fileName.diff");
        ByteArrayOutputStream os = new ByteArrayOutputStream();
        for (DiffEntry entry : diff) {
            try (DiffFormatter formatter = new DiffFormatter(os)) {

                formatter.setRepository(localRepo);
                formatter.format(entry);

                String aString = new String(os.toByteArray(), "UTF-8");
                String[] split = aString.split("diff --git ");

                for (int i = 1; i < split.length; i++) {
                    String[] filename = split[i].split("\n", 2);

                    int linelen = filename[0].length();
                    String name = "";

                    while (!(filename[0].charAt(linelen - 1) == '/')) {
                        name = filename[0].charAt(linelen - 1) + name;
                        linelen--;
                    }

                    String[] filecontent = split[i].split("@@\n", 2);

                    File diffFile = new File(commHash + File.separator + name);

                    try (Writer writer = new BufferedWriter(new OutputStreamWriter(
                            new FileOutputStream(diffFile.getAbsolutePath()), StandardCharsets.UTF_8))) {
                        writer.write(filecontent[1]);
                    } catch (Exception ex) {
                        ex.getMessage();
                    }

                    Path diffFilePath = Paths.get(diffFile.getAbsolutePath());
                    Charset charset = StandardCharsets.UTF_8;

                    String commitContent = Files.readString(diffFilePath, charset);
                    commitContent = commitContent.replaceAll(",", "COMMA");
                    commitContent = commitContent.replaceAll("\n", "\\N");

                    Files.write(diffFilePath, commitContent.getBytes(charset));

                    diffFilePaths.add(diffFile.getAbsolutePath());

                }
            }
        }

        logger.info("Diff files saved");
        return diffFilePaths;

    }


    /**
     * Collects a Diff from a specific commit
     *
     * @param commit
     * @return
     * @throws GitAPIException
     * @throws IOException
     */
    private List<DiffEntry> getDiff(RevCommit commit) throws GitAPIException, IOException {
        RevWalk rw = new RevWalk(localRepo);
        ObjectId head = localRepo.resolve(Constants.HEAD);
        RevCommit parent = rw.parseCommit(commit.getParent(0).getId());
        AbstractTreeIterator oldTreeParser = prepareTreeParser(localRepo, parent.getName());
        AbstractTreeIterator newTreeParser = prepareTreeParser(localRepo, commit.getName());

        List<DiffEntry> diff = git.diff().setOldTree(oldTreeParser).setNewTree(newTreeParser).call();
        return diff;
    }


    /**
     * Generate a TreeParser from a Tree that's obtained from a given commit to
     * allow for no inspection duplicates
     *
     * @param repository
     * @param objectId
     * @return
     * @throws IOException
     */
    private static AbstractTreeIterator prepareTreeParser(Repository repository, String objectId) throws IOException {

        try (RevWalk walk = new RevWalk(repository)) {
            RevCommit commit = walk.parseCommit(ObjectId.fromString(objectId));
            RevTree tree = walk.parseTree(commit.getTree().getId());

            CanonicalTreeParser treeParser = new CanonicalTreeParser();
            try (ObjectReader reader = repository.newObjectReader()) {
                treeParser.reset(reader, tree.getId());
            }

            walk.dispose();

            return treeParser;
        }
    }


    /**
     * Saves patch data of code before and after patch to csv locally
     * Also stores diff file contents to csv line as well
     * @param postPatchFileLocs
     * @param diffLocs
     */
    public void savePatchDataToCSV(ArrayList<String> prePatchFileLocs, ArrayList<String> postPatchFileLocs, ArrayList<String> diffLocs, String commitMessage) throws IOException {
        logger.info("Writing to CSV");

        Date today = new Date();
        today.setHours(0);

        StringBuilder data = new StringBuilder();

        // Folder in which bug finder data is stored
        File csv = new File(localOutput + File.separator + "csv");
        csv.mkdir();

        File output = new File( csv.getAbsolutePath() + File.separator + "bugFinderData" +
                today.getMonth() +"-" + today.getDay() + "-" + today.getYear() + ".csv");
        output.createNewFile();

        PrintWriter writer = new PrintWriter(new FileWriter(output.getAbsolutePath(), true));

        logger.info("Saving Commit file contents...");

        //Initialize data with header if data hasn't been inputted
        BufferedReader br = new BufferedReader(new FileReader(output));
        if (br.readLine() == null) {
            data.append("CVE-ID, CVE Description, Commit Message, Pre Patch Code, Post Patch Code, Diff, CWE-ID, Bug Framework Class\n");
        }

        data.append(cveId).append(",").append(description).append(",")
                .append(commitMessage.replaceAll(",", "COMMA").replaceAll("[\r\n]+", " ")
                        .trim()).append(",");

        logger.info("Getting pre patch code");
        getFileData(prePatchFileLocs, data);
        data.append(",");

        logger.info("Getting post patch code");
        getFileData(postPatchFileLocs, data);
        data.append(",");


        logger.info("Collecting Diff file contents...");
        getFileData(diffLocs, data);
        data.append(",");

        logger.info("Getting CWE ID and Bug Framework Class");
        getCWEId(data);
        data.append(",");

        logger.info("Getting Exploit Code");
        getExploitCode(data);
        data.append(",");

        logger.info("Writing to CSV...");
        data.append("\n");
        writer.append(data);
        writer.close();
        logger.info("Contents Saved To CSV");

    }

    /**
     * Repeated Extract method used for collecting file data from commit files
     * @param fileLocs
     * @param currentData
     * @return
     */
    private StringBuilder getFileData(ArrayList<String> fileLocs, StringBuilder currentData) {
        for (String fileLoc : fileLocs) {
            File commitFile = new File(fileLoc);

            if (commitFile.exists()) {
                currentData.append(commitFile.getName()).append(" --> ");

                StringBuilder data = new StringBuilder();
                try (BufferedReader br = new BufferedReader(new FileReader(commitFile))) {
                    String line;
                    while ((line = br.readLine()) != null) {
                        data.append(line);
                    }

                } catch (Exception e) {
                    logger.error(e.toString());
                }

                currentData.append(data.toString().replaceAll(",", "COMMA")
                        .replaceAll("\n", "\\N").trim());

                commitFile.delete();
            }
        }

        return currentData;
    }


    /**
     * Get's the CWE Id for the CVE and adds it to the CSV data
     * @param data
     */
    private void getCWEId(StringBuilder data)  {

        Properties properties = new Properties();

        try {
            FileInputStream input = new FileInputStream(new File("src/main/resources/nvip.properties"));
            properties.load(input);

            File dir = new File(properties.getProperty("dataLoc")).getAbsoluteFile();

            if (dir.isDirectory()) {
                File[] files = dir.listFiles();

                //Loop through xml data files for CVE
                if (files != null) {
                    for (File file : files) {
                        try {
                            FileInputStream fis = new FileInputStream(file);
                            Document doc = Jsoup.parse(fis, null, "", Parser.xmlParser());

                            //loop through bug frame work classes and CWE ids for the current CVE id
                            //Once found, append to csv data and return
                            for (Element bfClass : doc.select("Class")) {
                                for (Element cwe : bfClass.getElementsByTag("CWE")) {
                                    Elements cve = cwe.getElementsByAttributeValue("Name", cveId);

                                    if (!cve.isEmpty()) {
                                        data.append(cwe.attr("Id"))
                                                .append(",")
                                                .append(bfClass.attr("name"));
                                        return;
                                    }

                                }
                            }
                        } catch (FileNotFoundException e) {
                            logger.error("File " + file + " not found!");
                        } catch (Exception e) {
                            logger.error(e.toString());
                        }
                    }
                }
                ;
            }
        } catch (Exception e) {
            logger.error(e);
        }
    }

    /**
     * Get's exploit code from exploit-db and adds it to the data string
     * for CSV insertion
     * @param data
     */
    private void getExploitCode(StringBuilder data) {

        String exploitDBUrl = db.getExploitURL(cveId);

        if (!exploitDBUrl.isEmpty()) {
            try {

                Document doc = Jsoup.connect(exploitDBUrl).timeout(0).get();

                Element code = doc.select("code").get(0);

                 data.append(code.text().replaceAll(",", "COMMA")
                         .replaceAll("\n", "\\N").trim());

            } catch (Exception e) {
                logger.error(e.toString());
            }
        }
    }

}
